{"ast":null,"code":"import { useState, useRef, useEffect, useLayoutEffect } from 'react';\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar ConvertTimeToText = function ConvertTimeToText(time) {\n  if (!time) time = 0;\n  var minutes = \"0\" + Math.floor(time / 60);\n  var seconds = \"0\" + Math.floor(time - parseInt(minutes) * 60);\n  var result = minutes.substr(-2) + \":\" + seconds.substr(-2);\n  return result;\n};\nvar Reaplay = function Reaplay(_ref) {\n  var tracks = _ref.tracks,\n    _ref$startIndex = _ref.startIndex,\n    startIndex = _ref$startIndex === void 0 ? 0 : _ref$startIndex,\n    children = _ref.children;\n  if (startIndex < 0 || startIndex > tracks.length) {\n    startIndex = 0;\n  }\n  var _useState = useState(startIndex),\n    trackIndex = _useState[0],\n    setTrackIndex = _useState[1];\n  var _useState2 = useState(0),\n    trackProgress = _useState2[0],\n    setTrackProgress = _useState2[1];\n  var _useState3 = useState(100),\n    volume = _useState3[0],\n    setVolume = _useState3[1];\n  var _useState4 = useState(1),\n    speed = _useState4[0],\n    setSpeed = _useState4[1];\n  var _useState5 = useState(false),\n    isPlaying = _useState5[0],\n    setIsPlaying = _useState5[1];\n  var _useState6 = useState(false),\n    isRepeat = _useState6[0],\n    setIsRepeat = _useState6[1];\n  var _useState7 = useState(false),\n    isStopPlayMoreSong = _useState7[0],\n    StopPlayMoreSong = _useState7[1];\n  var _useState8 = useState(false),\n    isShuffleList = _useState8[0],\n    setIsShuffleList = _useState8[1];\n  var _useState9 = useState(false),\n    isMute = _useState9[0],\n    setIsMute = _useState9[1];\n  var _useState10 = useState(0),\n    buffered = _useState10[0],\n    setBuffered = _useState10[1];\n  var _useState11 = useState(0),\n    fourceRepeat = _useState11[0],\n    setFourceRepeat = _useState11[1];\n  var _useState12 = useState(true),\n    isLoading = _useState12[0],\n    setIsLoading = _useState12[1];\n  var _useState13 = useState(false),\n    isHaveError = _useState13[0],\n    setIsHaveError = _useState13[1];\n  var audioRef = useRef(new Audio(tracks[trackIndex]));\n  audioRef.current.autoplay = false;\n  audioRef.current.volume = volume / 100;\n  audioRef.current.muted = isMute;\n  audioRef.current.playbackRate = speed;\n  audioRef.current.onloadeddata = function () {\n    return setIsLoading(false);\n  };\n  audioRef.current.onerror = function () {\n    return setIsHaveError(true);\n  };\n  var intervalRef = useRef(null);\n  var isReady = useRef(false);\n  var duration = audioRef.current.duration;\n  var currentPercentage = duration ? trackProgress / duration * 100 + \"%\" : '0%';\n  var trackStyling = \"\\n      -webkit-gradient(linear, 0% 0%, 100% 0%, color-stop(\" + currentPercentage + \", #fff), color-stop(\" + currentPercentage + \", #777))\\n    \";\n  var startTimer = function startTimer() {\n    clearInterval(intervalRef.current);\n    intervalRef.current = setInterval(function () {\n      if (audioRef.current.ended) {\n        if (!isStopPlayMoreSong) {\n          if (isShuffleList) {\n            playRandom();\n          } else {\n            if (isRepeat) {\n              setFourceRepeat(function (prev) {\n                return prev + 1;\n              });\n            } else {\n              toNextTrack();\n            }\n          }\n        }\n      } else {\n        setTrackProgress(audioRef.current.currentTime);\n      }\n    }, 1000);\n  };\n  var onScrub = function onScrub(value) {\n    clearInterval(intervalRef.current);\n    audioRef.current.currentTime = value;\n    setTrackProgress(audioRef.current.currentTime);\n  };\n  var play = function play() {\n    setIsPlaying(true);\n  };\n  var pause = function pause() {\n    setIsPlaying(false);\n  };\n  var onScrubEnd = function onScrubEnd() {\n    if (!isPlaying) {\n      setIsPlaying(true);\n    }\n    startTimer();\n  };\n  var toPrevTrack = function toPrevTrack() {\n    if (isShuffleList) {\n      playRandom();\n    } else {\n      if (trackIndex - 1 < 0) {\n        setTrackIndex(tracks.length - 1);\n      } else {\n        setTrackIndex(trackIndex - 1);\n      }\n    }\n  };\n  var toNextTrack = function toNextTrack() {\n    if (isShuffleList) {\n      playRandom();\n    } else {\n      if (trackIndex < tracks.length - 1) {\n        setTrackIndex(trackIndex + 1);\n      } else {\n        setTrackIndex(0);\n      }\n    }\n  };\n  var forward = function forward() {\n    audioRef.current.currentTime += 5;\n  };\n  var backward = function backward() {\n    audioRef.current.currentTime -= 5;\n  };\n  var playSlow = function playSlow() {\n    setSpeed(0.5);\n  };\n  var playNormal = function playNormal() {\n    setSpeed(1);\n  };\n  var playFast = function playFast() {\n    setSpeed(2);\n  };\n  var repeat = function repeat(SetOnRepeat) {\n    if (SetOnRepeat) {\n      setIsRepeat(true);\n    } else {\n      setIsRepeat(false);\n    }\n  };\n  var mute = function mute() {\n    setIsMute(true);\n  };\n  var unmute = function unmute() {\n    setIsMute(false);\n  };\n  var playShuffle = function playShuffle(shuffle) {\n    if (shuffle) {\n      setIsShuffleList(true);\n    } else {\n      setIsShuffleList(false);\n    }\n  };\n  var playRandom = function playRandom() {\n    var songsLength = tracks.length - 1;\n    var random = Math.floor(Math.random() * songsLength);\n    setTrackIndex(random);\n  };\n  useEffect(function () {\n    if (isPlaying) {\n      audioRef.current.play();\n      startTimer();\n    } else {\n      audioRef.current.pause();\n    }\n  }, [isPlaying]);\n  useEffect(function () {\n    if (duration > 0) {\n      var i;\n      for (i = 0; i < audioRef.current.buffered.length; i++) {\n        setBuffered(audioRef.current.buffered.end(audioRef.current.buffered.length - 1 - i) / duration * 100);\n      }\n    }\n  }, [trackProgress]);\n  useLayoutEffect(function () {\n    audioRef.current.pause();\n    setIsPlaying(false);\n    setIsLoading(true);\n    setBuffered(0);\n    audioRef.current = new Audio(tracks[trackIndex]);\n    setTrackProgress(audioRef.current.currentTime);\n    audioRef.current.onloadeddata = function () {\n      return setIsLoading(false);\n    };\n    if (isReady.current) {\n      audioRef.current.play();\n      setIsPlaying(true);\n      startTimer();\n    } else {\n      isReady.current = true;\n    }\n  }, [trackIndex, fourceRepeat]);\n  useEffect(function () {\n    return function () {\n      audioRef.current.pause();\n      clearInterval(intervalRef.current);\n    };\n  }, []);\n  var Logger = function Logger() {\n    console.log({\n      trackIndex: trackIndex,\n      duration: ConvertTimeToText(duration),\n      trackProgress: ConvertTimeToText(trackProgress),\n      isPlaying: isPlaying,\n      isRepeat: isRepeat,\n      isShuffleList: isShuffleList,\n      isStopPlayMoreSong: isStopPlayMoreSong,\n      volume: volume,\n      isLoading: isLoading,\n      isHaveError: isHaveError,\n      speed: speed\n    });\n  };\n  var data = {\n    Logger: Logger,\n    isLoading: isLoading,\n    isHaveError: isHaveError,\n    trackIndex: trackIndex,\n    setTrackIndex: setTrackIndex,\n    duration: duration,\n    durationText: ConvertTimeToText(audioRef.current.duration),\n    trackProgress: trackProgress,\n    trackProgressText: ConvertTimeToText(trackProgress),\n    trackStyling: trackStyling,\n    onScrub: onScrub,\n    onScrubEnd: onScrubEnd,\n    isPlaying: isPlaying,\n    setIsPlaying: setIsPlaying,\n    play: play,\n    pause: pause,\n    toNextTrack: toNextTrack,\n    toPrevTrack: toPrevTrack,\n    isRepeat: isRepeat,\n    repeat: repeat,\n    volume: volume,\n    setVolume: setVolume,\n    isStopPlayMoreSong: isStopPlayMoreSong,\n    StopPlayMoreSong: StopPlayMoreSong,\n    playShuffle: playShuffle,\n    isShuffle: isShuffleList,\n    playRandom: playRandom,\n    isMute: isMute,\n    mute: mute,\n    unmute: unmute,\n    buffered: buffered,\n    bufferedText: buffered + \"%\",\n    backward: backward,\n    forward: forward,\n    speed: speed,\n    playSlow: playSlow,\n    playNormal: playNormal,\n    playFast: playFast\n  };\n  return children(_extends({}, data));\n};\nexport { Reaplay };","map":{"version":3,"names":["ConvertTimeToText","time","minutes","Math","floor","seconds","parseInt","result","substr","Reaplay","_ref","tracks","startIndex","_ref$startIndex","children","length","_useState","useState","trackIndex","setTrackIndex","_useState2","trackProgress","setTrackProgress","_useState3","volume","setVolume","_useState4","speed","setSpeed","_useState5","isPlaying","setIsPlaying","_useState6","isRepeat","setIsRepeat","_useState7","isStopPlayMoreSong","StopPlayMoreSong","_useState8","isShuffleList","setIsShuffleList","_useState9","isMute","setIsMute","_useState10","buffered","setBuffered","_useState11","fourceRepeat","setFourceRepeat","_useState12","isLoading","setIsLoading","_useState13","isHaveError","setIsHaveError","audioRef","useRef","Audio","current","autoplay","muted","playbackRate","onloadeddata","onerror","intervalRef","isReady","duration","currentPercentage","trackStyling","startTimer","clearInterval","setInterval","ended","playRandom","prev","toNextTrack","currentTime","onScrub","value","play","pause","onScrubEnd","toPrevTrack","forward","backward","playSlow","playNormal","playFast","repeat","SetOnRepeat","mute","unmute","playShuffle","shuffle","songsLength","random","useEffect","i","end","useLayoutEffect","Logger","console","log","data","durationText","trackProgressText","isShuffle","bufferedText","_extends"],"sources":["e:\\지수진\\NEW_ZISUZIN_2023\\03.SPA\\03.sources\\girls-pj\\node_modules\\reaplay\\src\\helper.ts","e:\\지수진\\NEW_ZISUZIN_2023\\03.SPA\\03.sources\\girls-pj\\node_modules\\reaplay\\src\\index.tsx"],"sourcesContent":["/**\n * convert time seconds to minutes : seconds\n * @function\n * @param {number} time\n * @description return the converted time like this = 03:14\n */\n\nexport const ConvertTimeToText = (time:number) => {\n    if(!time) time = 0;\n    var minutes:string = \"0\" + Math.floor(time / 60);\n    var seconds:string = \"0\" +  Math.floor(time - (parseInt(minutes)) * 60);\n    var result:string = minutes.substr(-2) + \":\" + seconds.substr(-2);\n    return result\n}","import { ReactNode, useEffect, useLayoutEffect, useRef, useState } from 'react'\nimport { ConvertTimeToText } from './helper'\n\ninterface Props {\n  tracks: string[]\n  startIndex?: number\n  children?: ((props: PlayerType) => ReactNode) | ReactNode\n}\n// prop types should be like this interface\n\n/**\n * Reaplay\n * @param {string[]} tracks\n * @param {number} startIndex\n * @param {any} children\n * @property {object}  player\n * @property {function} player.Logger\n * @property {boolean}  player.isLoading\n * @property {boolean}  player.isHaveError\n * @property {number}  player.trackIndex\n * @property {number}  player.setTrackIndex\n * @property {number}  player.duration\n * @property {string}  player.durationText\n * @property {number}  player.trackProgress\n * @property {string}  player.trackProgressText\n * @property {string}  player.trackStyling\n * @property {function}  player.onScrub\n * @property {function}  player.onScrubEnd\n * @property {boolean}  player.isPlaying\n * @property {function}  player.setIsPlaying\n * @property {function}  player.play\n * @property {function}  player.pause\n * @property {function}  player.toNextTrack\n * @property {function}  player.toPrevTrack\n * @property {boolean}  player.isRepeat\n * @property {function}  player.repeat\n * @property {number}  player.volume\n * @property {function}  player.setVolume\n * @property {number}  player.speed\n * @property {function}  player.playSlow\n * @property {function}  player.playNormal\n * @property {function}  player.playFast\n * @property {boolean}  player.isStopPlayMoreSong\n * @property {function}  player.StopPlayMoreSong\n * @property {boolean}  player.isShuffle\n * @property {function}  player.playShuffle\n * @property {function}  player.playRandom\n * @property {boolean}  player.isMute\n * @property {function}  player.mute\n * @property {function}  player.unmute\n * @property {number | string}  player.buffered\n * @property {string}  player.bufferedText\n * @property {function}  player.forward\n * @property {function}  player.backward\n */\nexport const Reaplay = ({ tracks, startIndex = 0, children }: Props) => {\n  if (startIndex < 0 || startIndex > tracks.length) {\n    startIndex = 0\n  }\n  // handle the undifind index\n  // -----------------------------------------------\n\n  /**\n   * here manage states\n   * use state because react need update with state if you change something\n   *\n   * @category states\n   */\n\n  // State\n  const [trackIndex, setTrackIndex] = useState<number>(startIndex)\n  // index of the tracks array on play\n\n  const [trackProgress, setTrackProgress] = useState<number>(0)\n  // played progress\n\n  const [volume, setVolume] = useState<number>(100)\n  // volume of the playing song\n\n  const [speed, setSpeed] = useState<number>(1)\n  // volume of the playing song\n\n  const [isPlaying, setIsPlaying] = useState<boolean>(false)\n  // play - puase\n\n  const [isRepeat, setIsRepeat] = useState<boolean>(false)\n  // repeat the playing song\n\n  const [isStopPlayMoreSong, StopPlayMoreSong] = useState<boolean>(false)\n  // if the song come on end, stop and dont play more\n\n  const [isShuffleList, setIsShuffleList] = useState<boolean>(false)\n  // shuffle list do anything ranodm, next - prev - on done\n\n  const [isMute, setIsMute] = useState<boolean>(false)\n  //  control the player mute, unmute\n\n  const [buffered, setBuffered] = useState<number>(0)\n  //  control the player mute, unmute\n\n  const [fourceRepeat, setFourceRepeat] = useState<number>(0)\n  const [isLoading, setIsLoading] = useState<boolean>(true)\n  const [isHaveError, setIsHaveError] = useState<boolean>(false)\n  // helper states\n\n  // =====================================================\n\n  // --------\n  // *\n  // *\n  // *\n  // ---------------------------\n  /**\n   * here manage audio\n   * here i use js Audio class and ref for manage audio props and functions\n   *\n   */\n  const audioRef = useRef(new Audio(tracks[trackIndex]))\n  audioRef.current.autoplay = false\n  audioRef.current.volume = volume / 100\n  audioRef.current.muted = isMute\n  audioRef.current.playbackRate = speed\n\n  audioRef.current.onloadeddata = () => setIsLoading(false)\n  audioRef.current.onerror = () => setIsHaveError(true)\n\n  const intervalRef: { current: NodeJS.Timeout | null } = useRef(null)\n  const isReady = useRef(false)\n  // ---------------------------\n  // *\n  // *\n  // *\n  // --------\n\n  // =============================\n  // Destructure for conciseness\n\n  // song duration\n  const { duration } = audioRef.current\n\n  const currentPercentage = duration\n    ? `${(trackProgress / duration) * 100}%`\n    : '0%'\n  const trackStyling = `\n      -webkit-gradient(linear, 0% 0%, 100% 0%, color-stop(${currentPercentage}, #fff), color-stop(${currentPercentage}, #777))\n    `\n  // ==============================\n\n  // ==== Timer\n  /**\n   * change scrub value\n   * @function\n   * @description start the timing of song and detect when the song to ended\n   */\n\n  const startTimer = () => {\n    // Clear any timers already running\n    clearInterval(intervalRef.current as NodeJS.Timeout)\n\n    intervalRef.current = setInterval(() => {\n      if (audioRef.current.ended) {\n        if (!isStopPlayMoreSong) {\n          if (isShuffleList) {\n            playRandom()\n          } else {\n            if (isRepeat) {\n              setFourceRepeat((prev) => prev + 1)\n            } else {\n              toNextTrack()\n            }\n          }\n        }\n      } else {\n        setTrackProgress(audioRef.current.currentTime)\n      }\n    }, 1000)\n  }\n\n  /**\n   * change scrub value\n   * @function\n   * @param {number} value - The value for set on scrub\n   * @description set the scrub value on changing time\n   *\n   * on scrub get the slider or range tag value and replace it with playing song progress\n   */\n\n  const onScrub = (value: number): void => {\n    // Clear any timers already running\n    clearInterval(intervalRef.current as NodeJS.Timeout)\n    audioRef.current.currentTime = value\n    setTrackProgress(audioRef.current.currentTime)\n  }\n\n  // -----------\n\n  /**\n   * play song\n   * @function\n   * @description play the current song\n   */\n\n  const play = (): void => {\n    setIsPlaying(true)\n  }\n\n  // -----------\n\n  /**\n   * pause song\n   * @function\n   * @description pause the current song\n   */\n\n  const pause = (): void => {\n    setIsPlaying(false)\n  }\n\n  // -----------\n\n  /**\n   * change scrub value\n   * @function\n   * @description set the scrub value on key or click\n   * @summary optional function\n   *\n   * this optional function\n   */\n\n  const onScrubEnd = (): void => {\n    // If not already playing, start\n    if (!isPlaying) {\n      setIsPlaying(true)\n    }\n    startTimer()\n  }\n\n  /**\n   * go to prev song\n   * @function\n   * @description go prev song at tracks list\n   *\n   * if shuffle play is on (true) the prev song do random\n   * if its first song, play at last song in tracks list\n   */\n\n  const toPrevTrack = (): void => {\n    if (isShuffleList) {\n      playRandom()\n    } else {\n      if (trackIndex - 1 < 0) {\n        setTrackIndex(tracks.length - 1)\n      } else {\n        setTrackIndex(trackIndex - 1)\n      }\n    }\n  }\n\n  /**\n   * go to next song\n   * @function\n   * @description go next song at tracks list\n   *\n   * if shuffle play is on (true) the next song do random\n   * if the last song, come at first song on tracks list\n   */\n\n  const toNextTrack = (): void => {\n    if (isShuffleList) {\n      playRandom()\n    } else {\n      if (trackIndex < tracks.length - 1) {\n        setTrackIndex(trackIndex + 1)\n      } else {\n        setTrackIndex(0)\n      }\n    }\n  }\n\n  /**\n   * forward\n   * @function\n   * @description forward to 5s later of playing song\n   */\n\n  const forward = (): void => {\n    audioRef.current.currentTime += 5\n  }\n\n  /**\n   * backward\n   * @function\n   * @description backward to 5s before of Track progress\n   */\n\n  const backward = (): void => {\n    audioRef.current.currentTime -= 5\n  }\n\n  /**\n   * playSlow\n   * @function\n   * @description set the player speed to (0.5)\n   */\n\n  const playSlow = (): void => {\n    setSpeed(0.5)\n  }\n\n  /**\n   * playNormal\n   * @function\n   * @description set the player speed to normal mode, (1)\n   */\n\n  const playNormal = (): void => {\n    setSpeed(1)\n  }\n\n  /**\n   * playFast\n   * @function\n   * @description set player speed to (2), it be play 2x faster than normal mode\n   */\n\n  const playFast = (): void => {\n    setSpeed(2)\n  }\n\n  /**\n   * repeat\n   * @function\n   * @description set player to repeat current song\n   */\n\n  const repeat = (SetOnRepeat: boolean): void => {\n    if (SetOnRepeat) {\n      setIsRepeat(true)\n    } else {\n      setIsRepeat(false)\n    }\n  }\n\n  /**\n   * mute\n   * @function\n   * @description mute the player\n   */\n\n  const mute = (): void => {\n    setIsMute(true)\n  }\n\n  /**\n   * unmute\n   * @function\n   * @description unmute the player\n   */\n\n  const unmute = (): void => {\n    setIsMute(false)\n  }\n\n  /**\n   * shuffle play\n   * @function\n   * @description play a random song in tracks list\n   *\n   * get a random index from tracks length and play it\n   */\n\n  const playShuffle = (shuffle: boolean): void => {\n    if (shuffle) {\n      setIsShuffleList(true)\n    } else {\n      setIsShuffleList(false)\n    }\n  }\n\n  const playRandom = (): void => {\n    let songsLength: number = tracks.length - 1\n    let random: number = Math.floor(Math.random() * songsLength)\n    setTrackIndex(random)\n  }\n\n  /**\n   * manage isPlay state for play or pause the song\n   * start timer for detect when the song ended or more ..\n   */\n\n  useEffect(() => {\n    if (isPlaying) {\n      audioRef.current.play()\n      startTimer()\n    } else {\n      audioRef.current.pause()\n    }\n  }, [isPlaying])\n\n  /**\n   * manage the buffered value of playing song\n   */\n  useEffect(() => {\n    if (duration > 0) {\n      let i\n      for (i = 0; i < audioRef.current.buffered.length; i++) {\n        setBuffered(\n          (audioRef.current.buffered.end(\n            audioRef.current.buffered.length - 1 - i\n          ) /\n            duration) *\n            100\n        )\n      }\n    }\n  }, [trackProgress])\n\n  /**\n   * manage track index and repeat time\n   * if track index changed, here be call ... and it change the audio ref src\n   * if fource update be called, it do anything at first\n   */\n\n  useLayoutEffect(() => {\n    audioRef.current.pause()\n    setIsPlaying(false)\n    setIsLoading(true)\n    setBuffered(0)\n\n    audioRef.current = new Audio(tracks[trackIndex])\n    setTrackProgress(audioRef.current.currentTime)\n    audioRef.current.onloadeddata = () => setIsLoading(false)\n\n    if (isReady.current) {\n      audioRef.current.play()\n      setIsPlaying(true)\n      startTimer()\n    } else {\n      // Set the isReady ref as true for the next pass\n      isReady.current = true\n    }\n  }, [trackIndex, fourceRepeat])\n\n  /**\n   * clean the memory and pause the song for manage memory leak and\n   */\n  useEffect(() => {\n    // Pause and clean up on unmount\n    return () => {\n      audioRef.current.pause()\n      clearInterval(intervalRef.current as NodeJS.Timeout)\n    }\n  }, [])\n\n  /**\n   * Logger\n   * @function\n   * @description get player state\n   *\n   * if some time you need get player states seconds by seconds can use it.\n   */\n\n  const Logger = (): void => {\n    console.log({\n      trackIndex,\n      duration: ConvertTimeToText(duration),\n      trackProgress: ConvertTimeToText(trackProgress),\n      isPlaying,\n      isRepeat,\n      isShuffleList,\n      isStopPlayMoreSong,\n      volume,\n      isLoading,\n      isHaveError,\n      speed\n    })\n  }\n\n  // *****************\n  // *********\n  // **\n  // ==============  return data\n  const data: PlayerType = {\n    Logger, // log the states\n    isLoading, // loading state\n    isHaveError, // error state\n    trackIndex, // playing index at tracks list\n    setTrackIndex, // set playing index at tracks list\n    duration, // playing song duration\n    durationText: ConvertTimeToText(audioRef.current.duration), // playing song duration by minutes and : spliter\n    trackProgress, // how much song played\n    trackProgressText: ConvertTimeToText(trackProgress), // how much song played by minutes and : spliter\n    trackStyling, // random style generated\n    onScrub, // on scrub function for change track progress\n    onScrubEnd,\n    isPlaying, // playing state\n    setIsPlaying, // playing state setter\n    play, // play current song\n    pause, // pause current song\n    toNextTrack, // play next song function\n    toPrevTrack, // play prevent song function\n    isRepeat, // repeat state\n    repeat, // set repeat state\n    volume, // volume state\n    setVolume, // set volume state\n    isStopPlayMoreSong, // stop play more song at song ended\n    StopPlayMoreSong, // set stop play more song\n    playShuffle, // play a random song at list function\n    isShuffle: isShuffleList, // is on shuffle or not\n    playRandom, // play a random song\n    isMute, // the player is mute\n    mute, // set player to mute\n    unmute, // set player to unmute\n    buffered, // the buffered value of the song\n    bufferedText: `${buffered}%`,\n    backward, // forward to 5s\n    forward, // backward to 5s\n    speed, // the speed range, 0.5 or 1 or 2\n    playSlow, // play slow playbackRate of track\n    playNormal, // play normal playbackRate of track\n    playFast // play fast playbackRate of track\n  }\n\n  // @ts-ignore\n  return children({\n    ...data\n  })\n}\n\nexport interface PlayerType {\n  Logger: Function\n  isLoading: boolean\n  isHaveError: boolean\n  trackIndex: number\n  setTrackIndex: (index: number) => void\n  duration: number\n  durationText: string\n  trackProgress: number\n  trackProgressText: string\n  trackStyling: string\n  onScrub: Function\n  onScrubEnd: Function\n  isPlaying: boolean\n  setIsPlaying: (isPlaying: boolean) => void\n  play: Function\n  pause: Function\n  toNextTrack: Function\n  toPrevTrack: Function\n  isRepeat: boolean\n  repeat: (setOnrepeat: boolean) => void\n  volume: number\n  setVolume: (volume: number) => void\n  speed: number\n  playSlow: Function\n  playNormal: Function\n  playFast: Function\n  isStopPlayMoreSong: boolean\n  StopPlayMoreSong: Function\n  playShuffle: (isShuffle: boolean) => void\n  isShuffle: boolean\n  playRandom: Function\n  isMute: boolean\n  mute: Function\n  unmute: Function\n  buffered: number | string\n  bufferedText: string\n  forward: Function\n  backward: Function\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}